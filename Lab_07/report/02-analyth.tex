\chapter{Аналитический раздел}\label{sec:analisys}

Данный раздел содержит информацию о словаре, в котором будет осуществлен поиск, сведения об организации словаря, подходу к сегментированию и описание алгоритмов полного перебора и бинарного поиска.

\section{Постановка задачи}

В данной лабораторной работе поиск в словаре реализовывается на примере словаря, основанного на тексте фанфика по фандому "Наруто". Клю­чом является номер слова в тексте, значением - соответственно само сло­во. Знаки препинания и прочие обозначения в тексте игнорируются.

\section{Алгоритм полного перебора}

Алгоритм полного перебора для любой задачи часто является са­мым примитивным и самым трудоемким алгоритмом, и в рамках рас­сматриваемой задачи этот случай не становится исключением. 
Для поставленной задачи алгоритм полного перебора заключает­ся в последовательном проходе по словарю до тех пор, пока не будет найден требуемый ключ. Очевидно, что худшим случаем является ситу­ация, когда необходимый ключ находится в конце словаря либо когда этот ключ вовсе не представлен в словаре. 
Трудоемкость алгоритма зависит от положения ключа в словаре - чем дальше он от начала словаря, тем больше единиц процессорного времени потребуется на поиск.

\section{Алгоритм бинарного поиска}

Алгоритм бинарного поиска применяется к заранее остортирован­ному набору значений. В рамках поставленной задачи словарь должен быть остортирован по ключам по возрастанию. \cite{knuth}

Основная идея бинарного поиска для поставленной задачи заклю­чается в следующем:
\begin{enumerate}
	\item Определение значения ключа в середине словаря. Полученное зна­чение сравнивается с искомым ключом;
	\item Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй;
	\item Поиск сводится к тому, что вновь определяется значение середин­ного элемента в выбранной половине и сравнивается с ключом;
	\item Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.
\end{enumerate}

Как известно, сложность алгоритма бинарного поиска на заранее упорядоченном наборе данных составляет $O(log2(n))$, где $n$ - размер словаря.

Однако, может возникнуть ситуация, что затраты на сортировку данных будут нивелировать преимущество быстрого поиска при больших размерностях массивов данных.

\section{Алгоритм частного анализа}

Для большей оптимизации поиска в словаре, предлагается разбить его на сегменты и отсортировать сегменты по их размеру. Критерием для разбиения предлагается выбрать первую букву слова. Сегменты при таком разбиении будут существенно варьироваться в размере, что подтверждает статистика на 2012 год \cite{wordstat}. При таком разбиении повышается вероятность того, что позиция искомого слова будет ближе к началу словаря, что значительно ускорит поиск.

Таким образом, в начале алгоритм получает словарь и ключ для поиска. Сначала происходит обращение к наиболее частому сегменту, а в нем ищется совпадение ключа с помощью двоичного поиска. Если ключ не найден в первом сегменте, происходит обращение к следующему сег­менту с последующим бинарным поиском до тех пор, пока не закончатся сегменты. Если ключ не найден ни в одном сегменте, то ключ не представлен в данном словаре и возникает ошибка доступа.

\section{Вывод}

Программное обеспечение, решающее поставленную задачу, может работать следующим образом. На вход алгоритму подается файл со словарем и искомый ключ, пользователь выбирает алгоритм поиска. Программа возвращает значение по искомому ключу и количество сравнений при поиске.

\section{Требования к ПО}

К программе предъявляются следующие требования:

\begin{enumerate}
	\item Программа должна предоставлять пользовательский интерфейс;
	\item Принципом разбиения на сегменты является анализ первой буквы слова;
	\item Пустой словарь - ошибочная ситуация;
	\item Программа не проверяет корректность входных файлов;
	\item Программа должна производить логирование для каждого из рас­смотренных алгоритмов - создаются файлы с соответствующим назва­нием, содержащие строки вида (номер ключа; количество сравнений во время поиска).
\end{enumerate}