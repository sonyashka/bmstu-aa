\chapter{Исследовательский раздел}

В данном разделе будет проведен сравнительный анализ алгоритмов по
времени и затрачиваемой памяти.

\section{Технические характеристики}

Тестирование выполнялось на устройстве со следующими характеристиками: 
\begin{itemize}
	\item операционная система Windows 10 \cite{windows10}
	\item память 8 Гб
	\item процессор Intel Core i3 7020U, 2.3 ГГц \cite{intel}
\end{itemize}

Во время проведения эксперимента устройство не было нагружено сторонними задачами, а также было подключено к блоку питания.

Замеры процессорного времени проводились с помощью ассемблерной вставки, вычисляющей затраченное процессорное время в тиках.

\captionsetup{singlelinecheck = false, justification=raggedright}
\begin{lstlisting}[label=tick, caption=Ассемблерная вставка замера процессорного времени в тиках]
unsigned long long tick(void)
{
    unsigned long long d;
    __asm__ __volatile__ ("rdtsc": "=A" (d));
    return d;
}
\end{lstlisting}
\captionsetup{singlelinecheck = false, justification=centering}

При проведении эксперимента была отключена оптимизация командой компилятору -o0 \cite{std=c99}.

\section{Оценка времени работы алгоритмов}

В таблицах 4.1 - 4.3 представлены замеры процессорного времени работы алгоритмов на квадратных матрицах размером от 50 до 550 элементов. Такая размерность выбрана, потому что на больших размерах массива происходит переполнение типа счетчика тиков. Каждое значение было получено усреднением по 10 замерам. 

Примем за лучший случай четную размерность, за худший - нечетную.

\begin{table}[H]
	\centering
	\caption{Временные замеры работы алгоритмов для лучшего случая}
	\begin{tabular}{l|r|r|r|r|r|r|r|r|r}
		\text{N} & \text{Standard} & \text{Vinograd} & \text{Vinograd (optimize)}\\
		\hline
		50 & 1000000 & 1000000 & 1000000\\
100 & 15000000 & 12000000 & 10000000\\
150 & 63000000 & 52000000 & 40000000\\
200 & 185000000 & 152000000 & 120000000\\
250 & 418000000 & 341000000 & 270000000\\
300 & 844000000 & 693000000 & 545000000\\
350 & 1572000000 & 1297000000 & 1023000000\\
400 & 2630000000 & 2168000000 & 1709000000\\
450 & 4187000000 & 3449000000 & 2723000000\\
500 & 6434000000 & 5462000000 & 4481000000\\
550 & 9540000000 & 7948000000 & 6432000000\\
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\caption{Временные замеры работы алгоритмов для худшего случая}
	\begin{tabular}{l|r|r|r|r|r|r|r|r|r}
		\text{N} & \text{Standard} & \text{Vinograd} & \text{Vinograd (optimize)}\\
		\hline
		51 & 1000000 & 1000000 & 1000000\\
101 & 18000000 & 12000000 & 9000000\\
151 & 66000000 & 51000000 & 40000000\\
201 & 186000000 & 149000000 & 117000000\\
251 & 443000000 & 358000000 & 283000000\\
301 & 864000000 & 707000000 & 557000000\\
351 & 1563000000 & 1282000000 & 1011000000\\
401 & 2678000000 & 2188000000 & 1717000000\\
451 & 4491000000 & 3719000000 & 2912000000\\
501 & 6669000000 & 5498000000 & 4318000000\\
551 & 9705000000 & 7972000000 & 6261000000\\
	\end{tabular}
\end{table}

На рисунке 4.1 представлен график сравнения времени работы алгоритмов на случайных данных. В результате эксперимента было получено, что на квадратных матрицах размером до 550 оптимизированный алгоритм Винограда работает на 40\% быстрее стандартного и на 25\% быстрее классического алгоритма Винограда.

\begin{figure}[H]
	\captionsetup{singlelinecheck = false, justification=centering}
	\centering
	\begin{tikzpicture}
			\begin{axis}[
				xlabel={размер массива},
				ylabel={время, тики},
				width=0.95\textwidth,
				height=0.3\textheight,
				xmin=0, xmax=600,
				legend pos=north west,
				xmajorgrids=true,
				grid style=dashed,
				]
				\addplot[
				color=blue,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					50 1000000
100 15000000
150 63000000
200 185000000
250 418000000
300 844000000
350 1572000000
400 2630000000
450 4187000000
500 6434000000
550 9540000000
				};
				\addplot[
				color=red,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					50 1000000
100 12000000
150 52000000
200 152000000
250 341000000
300 693000000
350 1297000000
400 2168000000
450 3449000000
500 5462000000
550 7948000000
				};
				\addplot[
				color=yellow,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					50 1000000
100 10000000
150 40000000
200 120000000
250 270000000
300 545000000
350 1023000000
400 1709000000
450 2723000000
500 4481000000
550 6432000000
				};
				\legend{Стандартный, Винограда, Винограда (оптим.)}
			\end{axis}
		\end{tikzpicture}
		\caption{Сравнение времени работы алгоритмов для лучшего случая}
\end{figure}

На рисунке 4.2 представлен график сравнения времени работы алгоритмов на отсортированных данных. В результате эксперимента было получено, что на квадратных матрицах размером до 551 алгоритмы показзывают примерно такие же результаты.

\begin{figure}[H]
	\captionsetup{singlelinecheck = false, justification=centering}
	\centering
	\begin{tikzpicture}
			\begin{axis}[
				xlabel={размер массива},
				ylabel={время, тики},
				width=0.95\textwidth,
				height=0.3\textheight,
				xmin=0, xmax=601,
				legend pos=north west,
				xmajorgrids=true,
				grid style=dashed,
				]
				\addplot[
				color=blue,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					51 1000000
101 18000000
151 66000000
201 186000000
251 443000000
301 864000000
351 1563000000
401 2678000000
451 4491000000
501 6669000000
551 9705000000
				};
				\addplot[
				color=red,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					51 1000000
101 12000000
151 51000000
201 149000000
251 358000000
301 707000000
351 1282000000
401 2188000000
451 3719000000
501 5498000000
551 7972000000
				};
				\addplot[
				color=yellow,
				mark=asterisk
				]
				table [x=N, y=time]{
					N time
					51 1000000
101 9000000
151 40000000
201 117000000
251 283000000
301 557000000
351 1011000000
401 1717000000
451 2912000000
501 4318000000
551 6261000000
				};
				\legend{Стандартный, Винограда, Винограда (оптим.)}
			\end{axis}
		\end{tikzpicture}
		\caption{Сравнение времени работы алгоритмов для худшего случая}
\end{figure}

\section{Вывод}

Реализиция стандартного алгоритма умножения матриц:
\begin{itemize}
	\item в лучшем случае - на 15\% медленнее алгоритма Винограда и на 30\% медленнее оптимизированного алгоритма Винограда;
	\item в худшем случае - на 18\% медленнее алгоритма Винограда и на 35\% медленнее оптимизированного алгоритма Винограда.
\end{itemize}

Также оптимизированный алгоритм Винограда дает выигрыш на 20\% относительно стандартного алгоритма Винограда независимо от данных.